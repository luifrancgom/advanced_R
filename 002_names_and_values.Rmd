---
title: "Names and values"
date: 2020-04-25 18:13:03
output:
  html_document:
    code_folding: hide
    df_print: paged
    highlight: tango
    number_sections: yes
    theme: flatly
    toc: yes
    toc_depth: 2
bibliography: advanced_R.bib
---

<style>

body {
text-align: justify}

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo      = TRUE, 
                      warning   = FALSE, 
                      message   = FALSE,
                      fig.align = "center")
```

```{r libraries}

library(lobstr)
library(knitr)
library(tidyverse)
```

# Names and values

This section is based on [@wickham_advanced_2019, Chapter 2]

## Introduction

- __Goal__: understand the distinction between names and values

- Understand the distinction between an object and its name is helpful because you can:

    + Predict the performance and memory usage of your code
    
    + Write faster code by avoiding accidental copies
    
    + Understand R’s functional programming tools
    
__Quiz__

1. Given the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use `$`, not `[[`. What makes 1, 2, and 3 challenging as variable names?

```{r}

set.seed(1234)

df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
print(df)

df$"3" <- df$"1" + df$"2"
print(df)
```
2. In the following code, how much memory does y occupy?

```{r}

set.seed(1234)

x <- runif(1e6)
y <- list(x, x, x)

object.size(x)
object.size(y)
```

- Why `y` is approximately the triple of `x`? 

    + `y` contains copies of `x`
    
3. On which line does a get copied in the following example?

```{r}

a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```

- I assume that on the second line `b <- a`

## Binding basics

Consider this code:

```{r}
x <- 1:3
```

It’s easy to read it as: __“create an object named ‘x’, containing the values 1, 2, and 3”___. Unfortunately, that’s a simplification that will lead to inaccurate. 

A more accurate description is:

- Creating an object, __a vector of values__, `1:3`

- Binding that object to a __name__, `x`

    + The object (or value) doesn’t have a name. It's actually the name that has a value

To further clarify this distinction let's use a diagram where there is a binding from the name on the left-hand side to the object on the right-hand side:

```{r fig.cap = "Source: [@wickham_advanced_2019, Chapter 2, Section 2.2]"}

include_graphics(path = "002_binding-1.png")
```
 For example, if you run this code, you don’t get another copy of the value c(1, 2, 3), you get another binding to the existing object:
 
```{r}

y <- x
```
 

```{r fig.cap = "Source: [@wickham_advanced_2019, Chapter 2, Section 2.2]"}

include_graphics(path = "002_binding-2.png")
```

You might have noticed that the value `1:3` has a label: `0x74b`. While the vector doesn't have a name, we will occasionally need to refer to an object independent of its bindings. To make that possible, we will label values with a unique identifier. You can access an object’s identifier with `lobstr::obj_addr()`:

```{r}

obj_addr(x)
obj_addr(y)
```

### Non-syntactic names

R has strict rules about what constitutes a valid name:

- Must consist of letters, digits, . and _

- Can’t begin with _ or a digit

- You can’t use any of the reserved words like `TRUE`, `NULL`, `if`, and `function`

    + see the complete list in `?Reserved`
    
A name that doesn’t follow these rules is a non-syntactic name. For example:

```{r, error=TRUE}

_abc <- 1
```

```{r, error=TRUE}
if   <- 10
```

It's possible to override these rules and use any name. For example:

```{r }

`_abc` <- 1
`if`   <- 10
```

__Observation__ : You can also create non-syntactic bindings using single or double quotes (e.g. `"_abc" <- 1`) instead of backticks, but you shouldn’t, because you’ll have to use a different syntax to retrieve the values

### Exercises

1. Explain the relationship between a, b, c and d in the following code

```{r}

a <- 1:10
b <- a
c <- b
d <- 1:10
```

- `a <- 1:10` means that `<-` assign the name `a` to the object `1:10` that has an associated identifier where we can access using `lobstr::obj_addr(a)`

    + `obj_addr(a)` gives the address of the value that `a` points to
    
- `b <- a` means that `<-` assign the name `b` to the same object `1:10` where `obj_addr(a)` $=$ `obj_addr(b)`

- `c <- b` means that `<-` assign the name `c` to the same object `1:10` where `obj_addr(b)` $=$ `obj_addr(c)`

```{r}

map_lgl(.x = list(obj_addr(b), 
                  obj_addr(b), 
                  obj_addr(c)), 
        .f = identical, obj_addr(a))
```


- `d <- 1:10` means that `<-` assign the name `d` to the object `1:10` but where `obj_addr(d)` $\neq$ `obj_addr(c)`

```{r}

map_lgl(.x = list(obj_addr(a), 
                  obj_addr(b), 
                  obj_addr(b), 
                  obj_addr(c)), 
        .f = identical, obj_addr(d))
```

2. The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with `lobstr::obj_addr()`

- `mean`
- `base::mean`  
- `get("mean")`
- `evalq(mean)`
- `match.fun("mean")`

Creating all the possible functions $f: A \rightarrow A$ where:

$$A = \{ \text{obj_addr(mean), obj_addr(base::mean), obj_addr(get("mean")), obj_addr(evalq(mean)), obj_addr(match.fun("mean"))} \}$$ 

without including the possibility of $f(a) = a$ where $a \in A$ and verifying if $f(a) \equiv b$

```{r}

map_lgl(.x = list(obj_addr(base::mean), 
                  obj_addr(get("mean")), 
                  obj_addr(evalq(mean)), 
                  obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(mean))

map_lgl(.x = list(obj_addr(get("mean")), 
                  obj_addr(evalq(mean)), 
                  obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(base::mean))

map_lgl(.x = list(obj_addr(evalq(mean)), 
                  obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(get("mean")))

map_lgl(.x = list(obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(evalq(mean)))
```

3. By default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behavior?



# Bibliography



