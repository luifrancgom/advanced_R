---
title: "Names and values"
date: 2020-04-25 18:13:03
output:
  html_document:
    code_folding: hide
    df_print: paged
    highlight: tango
    number_sections: yes
    theme: flatly
    toc: yes
    toc_depth: 2
bibliography: advanced_R.bib
---

<style>

body {
text-align: justify}

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo      = TRUE, 
                      warning   = FALSE, 
                      message   = FALSE,
                      fig.align = "center")
```

```{r libraries}

library(lobstr)
library(knitr)
```

# Names and values

This section is based on [@wickham_advanced_2019, Chapter 2]

## Introduction

- __Goal__: understand the distinction between names and values

- Understand the distinction between an object and its name is helpful because you can:

    + Predict the performance and memory usage of your code
    
    + Write faster code by avoiding accidental copies
    
    + Understand R’s functional programming tools
    
__Quiz__

1. Given the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use `$`, not `[[`. What makes 1, 2, and 3 challenging as variable names?

```{r}

set.seed(1234)

df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
print(df)

df$"3" <- df$"1" + df$"2"
print(df)
```
2. In the following code, how much memory does y occupy?

```{r}

set.seed(1234)

x <- runif(1e6)
y <- list(x, x, x)

object.size(x)
object.size(y)
```

- Why `y` is approximately the triple of `x`? 

    + `y` contains copies of `x`
    
3. On which line does a get copied in the following example?

```{r}

a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```

- I assume that on the second line `b <- a`

## Binding basics

Consider this code:

```{r}
x <- 1:3
```

It’s easy to read it as: __“create an object named ‘x’, containing the values 1, 2, and 3”___. Unfortunately, that’s a simplification that will lead to inaccurate. 

A more accurate description is:

- Creating an object, __a vector of values__, `1:3`

- Binding that object to a __name__, `x`

    + The object (or value) doesn’t have a name. It's actually the name that has a value

To further clarify this distinction let's use a diagram where there is a binding from the name on the left-hand side to the object on the right-hand side:

```{r fig.cap = "Source: [@wickham_advanced_2019, Chapter 2, Section 2.2]"}

include_graphics(path = "002_binding-1.png")
```
 For example, if you run this code, you don’t get another copy of the value c(1, 2, 3), you get another binding to the existing object:
 
```{r}

y <- x
```
 

```{r fig.cap = "Source: [@wickham_advanced_2019, Chapter 2, Section 2.2]"}

include_graphics(path = "002_binding-2.png")
```

You might have noticed that the value `1:3` has a label: `0x74b`. While the vector doesn't have a name, we will occasionally need to refer to an object independent of its bindings. To make that possible, we will label values with a unique identifier

# Bibliography



