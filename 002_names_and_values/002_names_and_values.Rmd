---
title: "Names and values"
date: 2020-04-25 18:13:03
output:
  html_document:
    code_folding: hide
    df_print: paged
    highlight: tango
    number_sections: yes
    theme: flatly
    toc: yes
    toc_depth: 2
bibliography: C:/Users/Asus/Desktop/personal_files/advanced_R/advanced_R.bib
---

<style>

body {
text-align: justify}

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo      = TRUE, 
                      warning   = FALSE, 
                      message   = FALSE,
                      fig.align = "center")
```

```{r libraries}

library(lobstr)
library(knitr)
library(tidyverse)
library(pryr)
```

# Names and values

This section is based on [@wickham_advanced_2019, Chapter 2]

## Introduction

- __Goal__: understand the distinction between names and values

- Understand the distinction between an object and its name is helpful because you can:

    + Predict the performance and memory usage of your code
    
    + Write faster code by avoiding accidental copies
    
    + Understand R’s functional programming tools
    
__Quiz__

1. Given the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use `$`, not `[[`. What makes 1, 2, and 3 challenging as variable names?

```{r}

set.seed(1234)

df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
print(df)

df$"3" <- df$"1" + df$"2"
print(df)
```
2. In the following code, how much memory does y occupy?

```{r}

set.seed(1234)

x <- runif(1e6)
y <- list(x, x, x)

object.size(x)
object.size(y)
```

- Why `y` is approximately the triple of `x`? 

    + `y` contains copies of `x`
    
3. On which line does a get copied in the following example?

```{r}

a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```

- I assume that on the second line `b <- a`

## Binding basics

Consider this code:

```{r}
x <- 1:3
```

It’s easy to read it as: __“create an object named ‘x’, containing the values 1, 2, and 3”___. Unfortunately, that’s a simplification that will lead to inaccurate. 

A more accurate description is:

- Creating an object, __a vector of values__, `1:3`

- Binding that object to a __name__, `x`

    + The object (or value) doesn’t have a name. It's actually the name that has a value

To further clarify this distinction let's use a diagram where there is a binding from the name on the left-hand side to the object on the right-hand side:

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.2]"}

include_graphics(path = "002_binding-1.png")
```
 For example, if you run this code, you don’t get another copy of the value c(1, 2, 3), you get another binding to the existing object:
 
```{r}

y <- x
```
 

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.2]"}

include_graphics(path = "002_binding-2.png")
```

You might have noticed that the value `1:3` has a label: `0x74b`. While the vector doesn't have a name, we will occasionally need to refer to an object independent of its bindings. To make that possible, we will label values with a unique identifier. You can access an object’s identifier with `lobstr::obj_addr()`:

```{r}

obj_addr(x)
obj_addr(y)
```

### Non-syntactic names

R has strict rules about what constitutes a valid name:

- Must consist of letters, digits, . and _

- Can’t begin with _ or a digit

- You can’t use any of the reserved words like `TRUE`, `NULL`, `if`, and `function`

    + see the complete list in `?Reserved`
    
A name that doesn’t follow these rules is a non-syntactic name. For example:

```{r, error=TRUE}

_abc <- 1
```

```{r, error=TRUE}
if   <- 10
```

It's possible to override these rules and use any name. For example:

```{r }

`_abc` <- 1
`if`   <- 10
```

__Observation__ : You can also create non-syntactic bindings using single or double quotes (e.g. `"_abc" <- 1`) instead of backticks, but you shouldn’t, because you’ll have to use a different syntax to retrieve the values

### Exercises

1. Explain the relationship between a, b, c and d in the following code

```{r}

a <- 1:10
b <- a
c <- b
d <- 1:10
```

- `a <- 1:10` means that `<-` assign the name `a` to the object `1:10` that has an associated identifier where we can access using `lobstr::obj_addr(a)`

    + `obj_addr(a)` gives the address of the value that `a` points to
    
- `b <- a` means that `<-` assign the name `b` to the same object `1:10` where `obj_addr(a)` $=$ `obj_addr(b)`

- `c <- b` means that `<-` assign the name `c` to the same object `1:10` where `obj_addr(b)` $=$ `obj_addr(c)`

```{r}

map_lgl(.x = list(obj_addr(b), 
                  obj_addr(b), 
                  obj_addr(c)), 
        .f = identical, obj_addr(a))
```


- `d <- 1:10` means that `<-` assign the name `d` to the object `1:10` but where `obj_addr(d)` $\neq$ `obj_addr(c)`

```{r}

map_lgl(.x = list(obj_addr(a), 
                  obj_addr(b), 
                  obj_addr(b), 
                  obj_addr(c)), 
        .f = identical, obj_addr(d))
```

2. The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with `lobstr::obj_addr()`

- `mean`
- `base::mean`  
- `get("mean")`
- `evalq(mean)`
- `match.fun("mean")`

Creating all the possible functions $f: A \rightarrow A$ where:

$$A = \{ \text{obj_addr(mean), obj_addr(base::mean), obj_addr(get("mean")), obj_addr(evalq(mean)), obj_addr(match.fun("mean"))} \}$$ 

without including the possibility of $f(a) = a$ where $a \in A$ and verifying if $f(a) \equiv b$

```{r}

map_lgl(.x = list(obj_addr(base::mean), 
                  obj_addr(get("mean")), 
                  obj_addr(evalq(mean)), 
                  obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(mean))

map_lgl(.x = list(obj_addr(get("mean")), 
                  obj_addr(evalq(mean)), 
                  obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(base::mean))

map_lgl(.x = list(obj_addr(evalq(mean)), 
                  obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(get("mean")))

map_lgl(.x = list(obj_addr(match.fun("mean"))), 
        .f = identical, obj_addr(evalq(mean)))
```

3. By default, base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behavior?

```{r}

# The original names of the columns are: if and _1234
## names of the variables in the data frame are checked to ensure that they are syntactically valid
## and adjusted using  make.names
df_syntactic_name <- read.csv(file = "002_exercise_2_2_2_3.csv",check.names = TRUE)
print(df_syntactic_name)

# names of the variables in the data frame are not checked
df__non_syntactic_name <- read.csv(file = "002_exercise_2_2_2_3.csv", check.names = FALSE)
print(print(df_syntactic_name))

# Using the tidyverse
tbl__non_syntactic_name <- read_csv(file = "002_exercise_2_2_2_3.csv")
print(tbl__non_syntactic_name)
```

- I think it is problematic because maybe you first need the names as they are to identify the variables from a document that explains the defintion of each variable. If they are changed you will be lost.    

4. What rules does `make.names()` use to convert non-syntactic names into syntactic ones?

- According to `?make.names`: 

    + The character "X" is prepended if necessary
    
    + All invalid characters are translated to "."
    
    + A missing value is translated to "NA"
    
    + Names which match R keywords have a dot appended to them
    
    + Duplicated values are altered by `make.unique`
    
```{r}
make.names(".123")
make.names("1$2 3")
make.names(NA)
make.names("for")
make.names(c("for", "for")) %>% make.unique()
```


5. I slightly simplified the rules that govern syntactic names. Why is `.123e1` not a syntactic name? Read `?make.names` for the full details

    + According to `?makenames` "A syntactically valid name consists of letters, numbers and the dot or underline characters and __starts with a letter or the dot not followed by a number.__ Names such as ".2way" are not valid, and neither are the reserved words." 
    
      + Therefore `.123e1` is a non-syntactic name because the dot is follow by number $1$ 

## Copy-on-modify

Consider the following code

```{r}

x <- c(1, 2, 3)
y <- x



y[3] <- 4

print(x)
print(y)
```

Modifying  `y` clearly didn't modify `x`

__Observation__ In the case of `Python`things are different:

```{python}

x = [1, 2, 3]
y = x

y[2] = 4

print(x)
print(y)
```
If you expect the same result in `Python` as in `R` you can do this:

```{python}

x = [1, 2, 3]
y = list(x)

y[2] = 4

print(x)
print(y)
```

While the value associated with `y` changed, the original object did not. Instead, R created a new object, `0xcd2`, a copy of `0x74b` with one value changed, then rebound `y` to that object:

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3]"}

include_graphics(path = "002_binding-3.png")
```

This behavior is called __copy-on-modify__. However there are important exceptions to copy-on-modify that you’ll learn in the following sections

### `tracemem()`

You can see when an object gets copied with the help of `base::tracemem()`

```{r}

x <- c(1, 2, 3)

tracemem(x)

y <- x

y[3] <- 4

# untracemem() is the opposite of tracemem(); it turns tracing off
untracemem(x)
```

### Function calls

The same rules for copying also apply to function calls. Take this code:

```{r}

f <- function(a) {
  
  a
  
}

x <- 1:3

tracemem(x)

z <- f(x)

untracemem(x)
```

While `f()` is running, the a inside the function points to the same value as the x does outside the function:

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.2]"}

include_graphics(path = "002_binding-f1.png")
```
We will learn more about the conventions used in this diagram in __Chapter 7__

Once `f()` completes, `x` and `z` will point to the same object

```{r}

obj_addr(x) == obj_addr(z)
```

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.2]"}

include_graphics(path = "002_binding-f2.png")
```

### Lists

It’s not just names (i.e. variables) that point to values: elements of lists do too

```{r}

l1 <- list(1, 2, 3)
```
However lists are more complex because instead of storing values, they store references to them:

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.3]"}

include_graphics(path = "002_list.png")
```

For example if you modify a list

```{r}

l2 <- l1

l2[[3]] <- 4
```

Initially you have 

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.3]"}

include_graphics(path = "002_l-modify-1.png")
```

But then after the modification you  have

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.3]"}

include_graphics(path = "002_l-modify-2.png")
```

Like vectors, lists use copy-on-modify behavior; the original list is left unchanged, and R creates a modified copy. This, however, is a __shallow copy__: the list object and its bindings are copied, but the values pointed to by the bindings are not.

To see values that are shared across lists, use `lobstr::ref()`

```{r}

print(ref(l1, l2))
```

## Data frames

Data frames are lists of vectors, so copy-on-modify has important consequences when you modify a data frame

```{r}

d1 <- data.frame(x = c(1, 5, 6), 
                 y = c(2, 4, 3))
```

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.4]"}

include_graphics(path = "002_dataframe.png")
```

If you modify a column, only that column needs to be modified

```{r}

d2 <- d1

d2[, 2] <- d2[, 2] + 1 

print(ref(d1, d2))
```

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.4]"}

include_graphics(path = "002_d-modify-c.png")
```

However, if you modify a row, every column is modified:

```{r }

d3 <- d1

d3[2, ] <- d3[2, ] + 1

print(ref(d1, d3))
```

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.4]"}

include_graphics(path = "002_d-modify-r.png")
```

### Character vectors

The final place that R uses references is with character vectors

```{r}

x <- c("a", "a", "abc", "d")
```

```{r fig.cap="Source: [@wickham_advanced_2019, Chapter 2, Section 2.3.5]"}

include_graphics(path = "002_character.png")
```

But this is a polite fiction. R actually uses a global string pool where each element of a character vector is a pointer to a unique string in the pool

```{r}

include_graphics(path = "002_character-2.png")
```

You can request that `ref()` show these references: 

```{r}

print(ref(x, character = TRUE))
```

### Exercises

1. Why is  `tracemem(1:10)` not useful?

Because `1:10` has not a name associated, so you can't copy `1:10` using `<-` 

2. Explain why `tracemem()` shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.

```{r}

x <- c(1L, 2L, 3L)

obj_addr(x)

tracemem(x)

x[[3]] <- 4
untracemem(x)

obj_addr(x)
```

- I think that the 2 copies are related to the change of the `class` in the object. Maybe `R` is doing something like this internally:

    + First  `x <- c(1L, 2L, 3L)`
    + Second `x <- c(1L, 2L, 4)`
    + Third  `x <- c(1, 2, 4)`
    
Another possibility, pointed out by  `@thisisdaryn (Daryn Ramsden)`, is `c(1, 2, NA)` due to the need to do the type conversion of the values that you're keeping and the necessity to only add one element.       

For example this code only includes one copy because the `class` of the object doesn't change:

```{r}

x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4L
untracemem(x)
```

And this code includes one copies

```{r}

x <- c(1L, 2L, 3L)
tracemem(x)

x[[10]] <- 4
untracemem(x)
```

However the only way to be sure according to `@thisisdaryn (Daryn Ramsden)`, is to inspect the `C` code for `[[<-`

```{r}

# pryr::show_c_source(.Primitive("[<-"))
```

3. Sketch out the relationship between the following objects:

```{r}

a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)
```


# Bibliography



